#define ARGUMENT_COUNT 6

#include <iostream>
#include <iomanip>
#include <vector>
#include <cassert>
#include <math.h>
#include <cstdlib>
#include <cstdint>
#include <ctime>
#include <mpi.h>
#include <sys/time.h>

using std::cout;
using std::cerr;
using std::endl;
using std::vector;
using std::uint8_t;
using std::uint16_t;
using std::uint32_t;

void matrixMultMod(int* M1,int* M2,int modP)
{
        int temp[4];
        //cout<<"multing:"<<M1[0]<<" "<<M1[1]<<" "<<M1[2]<<" "<<M1[3]<<" with "<<M2[0]<<" "<<M2[1]<<M2[2]<<" "<<M2[3]<<'\n';
        temp[0]=(M1[0]*M2[0]+M1[1]*M2[2])%modP;
        temp[1]=(M1[0]*M2[1]+M1[1]*M2[3])%modP;
        temp[2]=(M1[2]*M2[0]+M1[3]*M2[2])%modP;
        temp[3]=(M1[2]*M2[1]+M1[3]*M2[3])%modP;
        M1[0]=temp[0];
        M1[1]=temp[1];
        M1[2]=temp[2];
        M1[3]=temp[3];
        //cout<<"result is:"<<M1[0]<<" "<<M1[1]<<" "<<M1[2]<<" "<<M1[3]<<'\n';
}


void populate(int* ranseq,int (&MOffset)[4],int* initial,int a0,int b0,int p0,int x0, int input_size, int process_count)
{
        int rank;MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        //for(int i=0;i<input_size/process_count;i++)
         // {
                //cout<<"rank="<<rank<<" i="<<i<<" yields "<<myMatrices[i][0]<<" "<<myMatrices[i][1]<<" "<<myMatrices[i][2]<<" "<<myMatrices[i][3]<<'\n';
                //cout<<"\n"<<rank<<" says:"<<(MOffset[0])<<" "<<MOffset[1]<<" "<<MOffset[2]<<" "<<MOffset[3]<<'\n';
          //}
        matrixMultMod(&initial[0],MOffset,p0);
        ranseq[0]=(x0*initial[0]+initial[2])%p0;
        for(int i=1;i<input_size/process_count;i++)
        {
                ranseq[i]=(ranseq[i-1]*a0+b0)%p0;
        }
}

void initializeMatrices(int* initial,int a0,int b0,int p0,int input_size,int process_count, int* final)
{
        initial[0]=a0;
        initial[1]=0;
        initial[2]=b0;
        initial[3]=1;
        final[0]=a0;final[1]=0;final[2]=b0;final[3]=1;
        for(int i=1;i<input_size/process_count;i++)
        {
                matrixMultMod(&final[0],initial,p0);
        }
}


void parallelPrefix(int* out, int rank, int process_count,int p0, int (&local)[4])
{
        int in[4];
        bool done=false;
        int mate=rank;
        int stage=0; //this counts on which stage are we in, so we know which ranks will receive their required matrix
        for (int i=1; i<process_count;i=i*2)
        {
                if(rank%(2*i) < (i))
                {
                        mate=rank+i;
                }
                else
                {
                        mate=rank-i;
                }
                MPI_Status status;
                MPI_Sendrecv(&out[0],4,MPI_INT,mate,0,&in[0],4,MPI_INT,mate,0,MPI_COMM_WORLD,&status);

                //update the local matrix
                if(!done && mate<rank)
                {
                        matrixMultMod(&(local[0]),in,p0);
                }

                //in this case it already has what it needs
                if(ceil(log2(rank))==stage)
                        {
                                done=true;
                        }
                stage++;
                //in any case update the global matrix:
                matrixMultMod(&out[0],in,p0);
        }
                                                             
}

long getTime (struct timeval time_begin, struct timeval time_end) {
  return (time_end.tv_sec*1000000 + time_end.tv_usec) -
    (time_begin.tv_sec*1000000 + time_begin.tv_usec);
}

int main(int argc, char **argv) {
  assert(argc == ARGUMENT_COUNT);
  int input_size = atoi(argv[1]);
  int a0 = atoi(argv[2]);
  int b0 = atoi(argv[3]);
  int p0 = atoi(argv[4]);
  int x0 = atoi(argv[5]);
  assert(input_size > 0);
  assert(a0 > 0);
  assert(b0 > 0);
  assert(p0 > 0);
  assert(x0 > 0);
  int rank;
  int process_count;
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &process_count);
  
  struct timeval time_begin;
 // if(rank == 0)
   gettimeofday(&time_begin, NULL);
  int *initial;         //the first matrix of each rank; this is the M(a, 0; b, 1)
  int *final;   //the last matrix of each rank; this is M^(n/p)
  initial=new int[4];
  final=new int[4];

  int MOffset[4]={1,0,0,1};             //the prefix multMod for this rank that we will receive by parallel prefix
  int* ranseq;  //sequence of random numbers generated by this rank (to be filled at the end of the program)
  ranseq=new int[input_size/process_count];
  initializeMatrices(initial,a0,b0,p0,input_size,process_count,final);
  //calling the parallel prefix function
  parallelPrefix(&final[0],rank,process_count,p0,MOffset);
  //generate the random numbers using MOffset, local matrix of corresponding order and seed!
  populate(&ranseq[0],MOffset,initial,a0,b0,p0,x0,input_size,process_count);



  struct timeval time_end;
  int runtime = 0;


//if(rank == 0) {
  gettimeofday(&time_end, NULL);
  runtime += getTime(time_begin, time_end);
  if(rank!=0)
    {
      MPI_Send(&runtime,1,MPI_INT,0,0,MPI_COMM_WORLD);
    }
  else
    {
      int timercv;
      MPI_Status status;
      for(int i=1;i<process_count;i++)
	{
	  MPI_Recv(&timercv,1,MPI_INT,MPI_ANY_SOURCE,0,MPI_COMM_WORLD,&status);
	  //cout<<"received\n";	  
  	  if (timercv>runtime)
	    {
	      //cout<<"runtime was:"<<runtime<<'\n';
	      runtime=timercv;
	    }
	}
      printf("%16d %16d %16ld \n", process_count, input_size, runtime);
    }

  MPI_Finalize();
  return 0;
}
